/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : mapm
 #	author : miyako
 #	2018/09/21
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

std::mutex mutexMapm;

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :
            OnStartup();
            break;
            
        case kDeinitPlugin :
            OnExit();
            break;
            
// --- mapm

		case 1 :
			m_apm_gcd(pResult, pParams);
			break;

		case 2 :
			m_apm_lcm(pResult, pParams);
			break;

		case 3 :
			m_apm_add(pResult, pParams);
			break;

		case 4 :
			m_apm_subtract(pResult, pParams);
			break;

		case 5 :
			m_apm_multiply(pResult, pParams);
			break;

		case 6 :
			m_apm_divide(pResult, pParams);
			break;

		case 7 :
			m_apm_integer_divide(pResult, pParams);
			break;

		case 8 :
			m_apm_integer_div_rem(pResult, pParams);
			break;

		case 9 :
			m_apm_reciprocal(pResult, pParams);
			break;

		case 10 :
			m_apm_factorial(pResult, pParams);
			break;

		case 11 :
			m_apm_floor(pResult, pParams);
			break;

		case 12 :
			m_apm_ceil(pResult, pParams);
			break;

		case 13 :
			m_apm_get_random(pResult, pParams);
			break;

		case 14 :
			m_apm_sqrt(pResult, pParams);
			break;

		case 15 :
			m_apm_cbrt(pResult, pParams);
			break;

		case 16 :
			m_apm_log(pResult, pParams);
			break;

		case 17 :
			m_apm_log10(pResult, pParams);
			break;

		case 18 :
			m_apm_exp(pResult, pParams);
			break;

		case 19 :
			m_apm_pow(pResult, pParams);
			break;

		case 20 :
			m_apm_integer_pow(pResult, pParams);
			break;

		case 21 :
			m_apm_integer_pow_nr(pResult, pParams);
			break;

		case 22 :
			m_apm_sin_cos(pResult, pParams);
			break;

		case 23 :
			m_apm_sin(pResult, pParams);
			break;

		case 24 :
			m_apm_cos(pResult, pParams);
			break;

		case 25 :
			m_apm_tan(pResult, pParams);
			break;

		case 26 :
			m_apm_arcsin(pResult, pParams);
			break;

		case 27 :
			m_apm_arccos(pResult, pParams);
			break;

		case 28 :
			m_apm_arctan(pResult, pParams);
			break;

		case 29 :
			m_apm_arctan2(pResult, pParams);
			break;

		case 30 :
			m_apm_sinh(pResult, pParams);
			break;

		case 31 :
			m_apm_cosh(pResult, pParams);
			break;

		case 32 :
			m_apm_tanh(pResult, pParams);
			break;

		case 33 :
			m_apm_arcsinh(pResult, pParams);
			break;

		case 34 :
			m_apm_arccosh(pResult, pParams);
			break;

		case 35 :
			m_apm_arctanh(pResult, pParams);
			break;

		case 36 :
			m_apm_absolute_value(pResult, pParams);
			break;

		case 37 :
			m_apm_negate(pResult, pParams);
			break;

		case 38 :
			m_apm_round(pResult, pParams);
			break;

		case 39 :
			m_apm_compare(pResult, pParams);
			break;

		case 40 :
			m_apm_sign(pResult, pParams);
			break;

		case 41 :
			m_apm_exponent(pResult, pParams);
			break;

		case 42 :
			m_apm_significant_digits(pResult, pParams);
			break;

		case 43 :
			m_apm_is_integer(pResult, pParams);
			break;

		case 44 :
			m_apm_is_even(pResult, pParams);
			break;

		case 45 :
			m_apm_is_odd(pResult, pParams);
			break;

	}
}

#pragma mark done

void m_apm_add(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    m_apm_add(mapm1, mapm2, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
}

void m_apm_subtract(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    m_apm_subtract(mapm1, mapm2, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
}

void m_apm_multiply(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    m_apm_multiply(mapm1, mapm2, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
}

void m_apm_divide(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    M_APM mapm4 = m_apm_from_param_at_index(pParams, 4);

    if(places < 0) places = 0;
    
    m_apm_divide(mapm1, places, mapm3, mapm4);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
    m_apm_free(mapm4);
}

void m_apm_is_even(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    
    return_int(pResult, m_apm_is_even(mapm1));
    
    m_apm_free(mapm1);
}

void m_apm_is_odd(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    
    return_int(pResult, m_apm_is_odd(mapm1));
    
    m_apm_free(mapm1);
}

void m_apm_sign(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    
    return_int(pResult, m_apm_sign(mapm1));
    
    m_apm_free(mapm1);
}

void m_apm_exponent(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    
    return_int(pResult, m_apm_exponent(mapm1));
    
    m_apm_free(mapm1);
}

void m_apm_significant_digits(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    
    return_int(pResult, m_apm_significant_digits(mapm1));
    
    m_apm_free(mapm1);
}

void m_apm_is_integer(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    
    return_int(pResult, m_apm_is_integer(mapm1));
    
    m_apm_free(mapm1);
}

void m_apm_gcd(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    m_apm_gcd(mapm1, mapm2, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
}

void m_apm_lcm(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    m_apm_lcm(mapm1, mapm2, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
}

void m_apm_log(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);

    if(places < 0) places = 0;
    
    m_apm_log(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_log10(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_log10(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_absolute_value(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);

    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
   
    m_apm_absolute_value(mapm1, mapm2);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_negate(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    
    m_apm_negate(mapm1, mapm2);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_round(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_round(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_integer_divide(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    m_apm_integer_divide(mapm1, mapm2, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
}

void m_apm_reciprocal(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_reciprocal(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_factorial(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    
    m_apm_factorial(mapm1, mapm2);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_floor(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    
    m_apm_floor(mapm1, mapm2);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_ceil(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    
    m_apm_ceil(mapm1, mapm2);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_sqrt(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_sqrt(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_cbrt(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_cbrt(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_exp(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_exp(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_sin(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_sin(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_cos(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_cos(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_tan(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_tan(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_arcsin(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_arcsin(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_arccos(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_arccos(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_arctan(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_arctan(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_sinh(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_sinh(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_cosh(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_cosh(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_tanh(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_tanh(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_arcsinh(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_arcsinh(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_arccosh(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_arccosh(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_arctanh(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    
    if(places < 0) places = 0;
    
    m_apm_arctanh(mapm1, places, mapm3);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_integer_div_rem(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_init();
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    M_APM mapm4 = m_apm_from_param_at_index(pParams, 4);
    
    m_apm_integer_div_rem(mapm1, mapm2, mapm3, mapm4);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    m_apm_to_param_at_index(mapm1, pParams, 2);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm3);
    m_apm_free(mapm4);
}

void m_apm_compare(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);

    M_APM mapm1 = m_apm_from_param_at_index(pParams, 1);
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    
    return_int(pResult, m_apm_compare(mapm1, mapm2));
 
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_get_random(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    
    m_apm_get_random(mapm1);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
}

void m_apm_arctan2(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    M_APM mapm4 = m_apm_from_param_at_index(pParams, 4);

    m_apm_arctan2(mapm1, places, mapm3, mapm4);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
    m_apm_free(mapm4);
}

void m_apm_pow(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    M_APM mapm4 = m_apm_from_param_at_index(pParams, 4);
    
    m_apm_pow(mapm1, places, mapm3, mapm4);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
    m_apm_free(mapm4);
}

void m_apm_integer_pow(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    int places = int_from_param_at_index(pParams, 2);
    M_APM mapm3 = m_apm_from_param_at_index(pParams, 3);
    int mexp = int_from_param_at_index(pParams, 4);
    
    m_apm_integer_pow(mapm1, places, mapm3, mexp);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm3);
}

void m_apm_integer_pow_nr(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_from_param_at_index(pParams, 2);
    int mexp = int_from_param_at_index(pParams, 3);
    
    m_apm_integer_pow_nr(mapm1, mapm2, mexp);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
}

void m_apm_sin_cos(sLONG_PTR *pResult, PackagePtr pParams)
{
    std::lock_guard<std::mutex> lock(mutexMapm);
    
    M_APM mapm1 = m_apm_init();
    M_APM mapm2 = m_apm_init();
    int places = int_from_param_at_index(pParams, 3);
    M_APM mapm4 = m_apm_from_param_at_index(pParams, 4);
    
    m_apm_sin_cos(mapm1, mapm2, places, mapm4);
    
    m_apm_to_param_at_index(mapm1, pParams, 1);
    
    m_apm_free(mapm1);
    m_apm_free(mapm2);
    m_apm_free(mapm4);
}

// ------------------------------------- mapm -------------------------------------

#pragma mark -

void OnStartup()
{
    long long int t = 0;
    
#if VERSIONWIN
    static const __int64 SECS_BETWEEN_1601_AND_1970_EPOCHS = 116444736000000000LL;
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    ULARGE_INTEGER ul;
    ul.LowPart = ft.dwLowDateTime;
    ul.HighPart = ft.dwHighDateTime;
    t = (long long int)((ul.QuadPart - SECS_BETWEEN_1601_AND_1970_EPOCHS) / 10000);
#else
    struct timeb timer_msec;
    if (!ftime(&timer_msec))
    {
        t = ((long long int) timer_msec.time) * 1000ll + (long long int) timer_msec.millitm;
    }
#endif
    
    std::vector<char>buf(100);
    snprintf ( (char *)&buf[0], 100, "%lld", t);
    m_apm_set_random_seed(&buf[0]);
}

void OnExit()
{
    m_apm_free_all_mem();
}

#pragma mark -

void m_apm_to_param_at_index(M_APM mapm, PackagePtr pParams, uint16_t index)
{
    if(index)
    {
        int significant_digits = m_apm_significant_digits(mapm);
        int sign = m_apm_sign(mapm);
        int exponent = m_apm_exponent(mapm);
        int is_integer = m_apm_is_integer(mapm);
        int digit = significant_digits - exponent - 1;
        
        int buf_size = significant_digits + (sign == 1 ? 0 : 1) + (exponent < 0 ? abs(exponent) : 0) + (is_integer ? 0 : 1) + 1;
        
        std::vector<char>buf(buf_size);
        m_apm_to_fixpt_string(&buf[0],  is_integer ? 0 : digit, mapm);
        
#ifdef _WIN32
        LPCSTR str = (LPCSTR)&buf[0];
        int size = strlen(&buf[0]);
        int len = MultiByteToWideChar(CP_UTF8, 0, str, size, NULL, 0);
        if(len)
        {
            std::vector<uint8_t> buffer((len + 1) * sizeof(PA_Unichar));
            if(MultiByteToWideChar(CP_UTF8, 0, str, size, (LPWSTR)&buffer[0], len))
            {
                PA_SetUnistring(
                                (PA_Unistring *)(pParams[index - 1]),
                                (PA_Unichar *)&buffer[0]
                                );
            }
        }
#else
        const UInt8 *bytes = (const UInt8 *)&buf[0];
        CFIndex size = strlen((char *)bytes);
        CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, bytes, size, kCFStringEncodingUTF8, true);
        if(str)
        {
            CFIndex len = CFStringGetLength(str);
            std::vector<uint8_t> buffer((len + 1) * sizeof(PA_Unichar));
            CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buffer[0]);
            PA_SetUnistring(
                            (PA_Unistring *)(pParams[index - 1]),
                            (PA_Unichar *)&buffer[0]
                            );
            CFRelease(str);
        }
#endif
    }
    
}

void return_int(sLONG_PTR *pResult, int value)
{
    *(int *) pResult = value;
}

int int_from_param_at_index(PackagePtr pParams, uint16_t index)
{
    int value = 0;
    
    if(index)
    {
        value = *(int *)(pParams[index - 1]);
    }
    return value;
}

M_APM m_apm_from_param_at_index(PackagePtr pParams, uint16_t index)
{
    M_APM mapm = m_apm_init();
    if(index)
    {
        PA_Unistring *str = (PA_Unistring *)(pParams[index - 1]);
#ifdef _WIN32
        LPCWSTR cwstr = (LPCWSTR)str->fString;
        int size = str->fLength;
        int len = WideCharToMultiByte(CP_UTF8, 0, cwstr, size, NULL, 0, NULL, NULL);
        if(len)
        {
            std::vector<uint8_t> buf(len + 1);
            if(WideCharToMultiByte(CP_UTF8, 0, cwstr, size, (LPSTR)&buf[0], len, NULL, NULL))
            {
                m_apm_set_string(mapm, (char *)std::string((char *)&buf[0], len).c_str());
            }
        }
#else
        CFStringRef cfstr = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)str->fString, str->fLength);
        if(cfstr)
        {
            size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(cfstr), kCFStringEncodingUTF8) + sizeof(uint8_t);
            std::vector<uint8_t> buf(size);
            CFIndex len;
            CFStringGetBytes(cfstr, CFRangeMake(0, CFStringGetLength(cfstr)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
            m_apm_set_string(mapm, (char *)std::string((char *)&buf[0], len).c_str());
            CFRelease(cfstr);
        }
#endif
    }
    return mapm;
}
